---
alwaysApply: true
---
# Data Handling Architecture Rules

This project follows strict architectural patterns for data handling to ensure consistency, security, and type safety.

## Centralized Database Operations

**ALL database operations MUST be centralized in helper functions within the `db/queries` directory.** This ensures code reusability, consistency, and easier maintenance.

### Query Helper Functions Structure

All database queries should be organized in the `db/queries` directory by domain:

```
db/
  queries/
    deck-queries.ts    # Deck-related database operations
    card-queries.ts    # Card-related database operations
```

### ✅ CORRECT: Query Helper Functions
```typescript
// db/queries/deck-queries.ts
import { auth } from "@clerk/nextjs/server";
import { db } from "@/db";
import { decksTable, cardsTable } from "@/db/schema";
import { eq, and, sql } from "drizzle-orm";

export async function getUserDecks() {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }

  return await db.select({
    id: decksTable.id,
    title: decksTable.title,
    description: decksTable.description,
    createdAt: decksTable.createdAt,
    updatedAt: decksTable.updatedAt,
    cardCount: sql<number>`count(${cardsTable.id})`.as('cardCount')
  })
    .from(decksTable)
    .leftJoin(cardsTable, eq(decksTable.id, cardsTable.deckId))
    .where(eq(decksTable.userId, userId))
    .groupBy(decksTable.id)
    .orderBy(decksTable.updatedAt);
}

export async function getDeckById(deckId: string) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }

  const [deck] = await db.select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));

  if (!deck) {
    throw new Error("Deck not found or access denied");
  }

  return deck;
}

export async function getDeckWithCards(deckId: string) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }

  // Verify deck ownership first
  await getDeckById(deckId);

  const deck = await db.select()
    .from(decksTable)
    .leftJoin(cardsTable, eq(decksTable.id, cardsTable.deckId))
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));

  if (!deck.length) {
    throw new Error("Deck not found");
  }

  return deck;
}
```

## Server Components for Data Retrieval

**ALL data retrieval in Server Components MUST use helper functions from `db/queries`**, never direct database calls.

### ✅ CORRECT: Server Component Using Query Helper
```typescript
// app/decks/page.tsx - Server Component
import { getUserDecks } from "@/db/queries/deck-queries";
import { redirect } from "next/navigation";

export default async function DecksPage() {
  try {
    const decks = await getUserDecks(); // Using helper function

    return (
      <div>
        {decks.map(deck => (
          <DeckCard key={deck.id} deck={deck} />
        ))}
      </div>
    );
  } catch (error) {
    if (error.message === "Unauthorized") {
      redirect("/");
    }
    throw error;
  }
}
```

### ✅ CORRECT: Server Component with Parameters
```typescript
// app/decks/[deckId]/page.tsx - Server Component
import { getDeckWithCards } from "@/db/queries/deck-queries";
import { notFound } from "next/navigation";

export default async function DeckPage({ params }: { params: { deckId: string } }) {
  try {
    const deckWithCards = await getDeckWithCards(params.deckId);

    return (
      <div>
        <h1>{deckWithCards[0].decks.title}</h1>
        {/* Render cards */}
      </div>
    );
  } catch (error) {
    if (error.message === "Deck not found or access denied") {
      notFound();
    }
    throw error;
  }
}
```

### ❌ FORBIDDEN: Client Component Data Fetching
```typescript
// DON'T DO THIS - Client component fetching data
"use client";
export function DecksPage() {
  const [decks, setDecks] = useState([]);
  
  useEffect(() => {
    // This is forbidden - use Server Components instead
    fetch('/api/decks').then(res => res.json()).then(setDecks);
  }, []);
}
```

## Mutation Helper Functions

**ALL database mutations (INSERT, UPDATE, DELETE) MUST be centralized in helper functions within the `db/queries` directory.**

### ✅ CORRECT: Mutation Helper Functions
```typescript
// db/queries/deck-queries.ts (continued)
import { z } from "zod";

// Zod schemas for mutations
export const CreateDeckSchema = z.object({
  title: z.string().min(1, "Title is required").max(100, "Title too long"),
  description: z.string().max(500, "Description too long").optional(),
});

export const UpdateDeckSchema = z.object({
  id: z.string().uuid("Invalid deck ID"),
  title: z.string().min(1, "Title is required").max(100, "Title too long"),
  description: z.string().max(500, "Description too long").optional(),
});

export type CreateDeckInput = z.infer<typeof CreateDeckSchema>;
export type UpdateDeckInput = z.infer<typeof UpdateDeckSchema>;

export async function createDeck(input: CreateDeckInput) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // Validate input with Zod
  const validatedInput = CreateDeckSchema.parse(input);
  
  const [newDeck] = await db.insert(decksTable).values({
    ...validatedInput,
    userId,
    createdAt: new Date(),
    updatedAt: new Date()
  }).returning();
  
  return newDeck;
}

export async function updateDeck(input: UpdateDeckInput) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // Validate input with Zod
  const validatedInput = UpdateDeckSchema.parse(input);
  
  // Verify ownership before update
  await getDeckById(validatedInput.id);
  
  const [updatedDeck] = await db.update(decksTable)
    .set({
      title: validatedInput.title,
      description: validatedInput.description,
      updatedAt: new Date()
    })
    .where(and(
      eq(decksTable.id, validatedInput.id),
      eq(decksTable.userId, userId)
    ))
    .returning();
    
  return updatedDeck;
}

export async function deleteDeck(deckId: string) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // Verify ownership before deletion
  await getDeckById(deckId);
  
  await db.delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
}
```

## Server Actions for Data Mutations

**ALL Server Actions MUST use helper functions from `db/queries` for database operations**, never direct database calls.

### ✅ CORRECT: Server Action Using Mutation Helper
```typescript
// lib/actions/deck-actions.ts
"use server";

import { createDeck, updateDeck, deleteDeck } from "@/db/queries/deck-queries";
import type { CreateDeckInput, UpdateDeckInput } from "@/db/queries/deck-queries";
import { revalidatePath } from "next/cache";

export async function createDeckAction(input: CreateDeckInput) {
  try {
    const newDeck = await createDeck(input); // Using helper function
    revalidatePath("/decks");
    return { success: true, data: newDeck };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function updateDeckAction(input: UpdateDeckInput) {
  try {
    const updatedDeck = await updateDeck(input); // Using helper function
    revalidatePath("/decks");
    revalidatePath(`/decks/${input.id}`);
    return { success: true, data: updatedDeck };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function deleteDeckAction(deckId: string) {
  try {
    await deleteDeck(deckId); // Using helper function
    revalidatePath("/decks");
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}
```

### ❌ FORBIDDEN: API Route Mutations
```typescript
// DON'T DO THIS - API routes for mutations
export async function POST(request: Request) {
  // This pattern is forbidden - use Server Actions instead
  const data = await request.json();
  await db.insert(decksTable).values(data);
}
```

## Zod Validation Requirements

**ALL data validation MUST use Zod schemas** for both input validation and type inference.

### Required Patterns

1. **Define Zod Schema First:**
```typescript
import { z } from "zod";

const UpdateCardSchema = z.object({
  id: z.string().uuid("Invalid card ID"),
  front: z.string().min(1, "Front text is required"),
  back: z.string().min(1, "Back text is required"),
  deckId: z.string().uuid("Invalid deck ID"),
});

type UpdateCardInput = z.infer<typeof UpdateCardSchema>;
```

2. **Validate in Server Action:**
```typescript
export async function updateCard(input: UpdateCardInput) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  // Always validate with Zod
  const validatedInput = UpdateCardSchema.parse(input);
  
  // Verify ownership before update
  await verifyCardOwnership(validatedInput.id, userId);
  
  const [updatedCard] = await db.update(cardsTable)
    .set({
      front: validatedInput.front,
      back: validatedInput.back,
      updatedAt: new Date()
    })
    .where(eq(cardsTable.id, validatedInput.id))
    .returning();
    
  revalidatePath(`/decks/${validatedInput.deckId}`);
  return updatedCard;
}
```

3. **Client-Side Form Handling:**
```typescript
"use client";

import { updateCard } from "@/lib/actions/card-actions";
import { UpdateCardInput } from "@/lib/schemas/card-schemas";

export function EditCardForm({ card }: { card: Card }) {
  const handleSubmit = async (formData: FormData) => {
    // Transform FormData to typed object
    const input: UpdateCardInput = {
      id: card.id,
      front: formData.get("front") as string,
      back: formData.get("back") as string,
      deckId: card.deckId,
    };
    
    try {
      await updateCard(input);
      // Handle success
    } catch (error) {
      // Handle validation or other errors
    }
  };

  return (
    <form action={handleSubmit}>
      <input name="front" defaultValue={card.front} />
      <input name="back" defaultValue={card.back} />
      <button type="submit">Update Card</button>
    </form>
  );
}
```

## Forbidden Patterns

### ❌ DO NOT make direct database calls in Server Components
```typescript
// WRONG - Direct database call in Server Component
import { db } from "@/db";
import { decksTable } from "@/db/schema";

export default async function DecksPage() {
  const decks = await db.select().from(decksTable); // Direct DB call
  return <div>{/* render decks */}</div>;
}

// CORRECT - Use helper function
import { getUserDecks } from "@/db/queries/deck-queries";

export default async function DecksPage() {
  const decks = await getUserDecks(); // Helper function
  return <div>{/* render decks */}</div>;
}
```

### ❌ DO NOT make direct database calls in Server Actions
```typescript
// WRONG - Direct database call in Server Action
"use server";
import { db } from "@/db";
import { decksTable } from "@/db/schema";

export async function createDeckAction(input: CreateDeckInput) {
  const [newDeck] = await db.insert(decksTable).values(input); // Direct DB call
  return newDeck;
}

// CORRECT - Use helper function
"use server";
import { createDeck } from "@/db/queries/deck-queries";

export async function createDeckAction(input: CreateDeckInput) {
  const newDeck = await createDeck(input); // Helper function
  return newDeck;
}
```

### ❌ DO NOT use FormData types in Server Actions
```typescript
// WRONG - Don't use FormData as parameter type
export async function createDeck(formData: FormData) {
  const title = formData.get("title") as string; // Type unsafe
}

// CORRECT - Use typed parameters with helper functions
export async function createDeckAction(input: CreateDeckInput) {
  const newDeck = await createDeck(input); // Helper function with types
}
```

### ❌ DO NOT skip Zod validation in helper functions
```typescript
// WRONG - No validation in helper function
export async function createDeck(input: any) {
  await db.insert(decksTable).values(input);
}

// CORRECT - Always validate in helper functions
export async function createDeck(input: CreateDeckInput) {
  const validatedInput = CreateDeckSchema.parse(input);
  await db.insert(decksTable).values(validatedInput);
}
```

### ❌ DO NOT use API routes for mutations
```typescript
// WRONG - API route for database mutation
export async function POST(request: Request) {
  const data = await request.json();
  await db.insert(decksTable).values(data);
}

// CORRECT - Server Action using helper function
"use server";
export async function createDeckAction(input: CreateDeckInput) {
  const newDeck = await createDeck(input); // Helper function
  return newDeck;
}
```

### ❌ DO NOT fetch data in Client Components
```typescript
// WRONG - Client-side data fetching
"use client";
export function DecksPage() {
  const [decks, setDecks] = useState([]);
  useEffect(() => {
    fetch('/api/decks').then(res => res.json()).then(setDecks);
  }, []);
}

// CORRECT - Server Component using helper function
export default async function DecksPage() {
  const decks = await getUserDecks(); // Helper function in Server Component
  return <DecksClient decks={decks} />;
}
```

### ❌ DO NOT duplicate authentication logic
```typescript
// WRONG - Authentication logic repeated everywhere
export default async function DecksPage() {
  const { userId } = await auth();
  if (!userId) redirect("/");
  const decks = await db.select().from(decksTable).where(eq(decksTable.userId, userId));
}

// CORRECT - Authentication handled in helper functions
export default async function DecksPage() {
  const decks = await getUserDecks(); // Auth handled inside helper
}
```

## Required Dependencies

Ensure these packages are installed:
```bash
npm install zod @types/node
```

## File Organization

- **Database Query Helpers:** `db/queries/` directory (REQUIRED - all database operations)
  - `db/queries/deck-queries.ts` - Deck-related queries and mutations
  - `db/queries/card-queries.ts` - Card-related queries and mutations
- **Server Actions:** `lib/actions/` directory (thin wrappers around query helpers)
- **Zod Schemas:** Co-located with query helpers in `db/queries/` files
- **Server Components:** `app/` directory (page.tsx, layout.tsx) - use query helpers
- **Client Components:** `components/` directory

## Best Practices Summary

1. **Centralize all database operations** in `db/queries/` helper functions
2. **Include authentication and validation** in every helper function
3. **Use query helpers in Server Components** for data fetching
4. **Use query helpers in Server Actions** for mutations
5. **Never make direct database calls** outside of helper functions
6. **Co-locate Zod schemas** with their related query helpers
7. **Handle errors appropriately** with proper HTTP status codes
8. **Maintain consistent naming conventions** across helper functions

## Example Project Structure

```
db/
  queries/
    deck-queries.ts       # getUserDecks, createDeck, updateDeck, deleteDeck
    card-queries.ts       # getDeckCards, createCard, updateCard, deleteCard
lib/
  actions/
    deck-actions.ts       # Server Actions using deck query helpers
    card-actions.ts       # Server Actions using card query helpers
app/
  decks/
    page.tsx             # Server Component using getUserDecks
    [deckId]/
      page.tsx           # Server Component using getDeckWithCards
components/
  ui/                    # shadcn/ui components
  deck-card.tsx          # Client Components for UI
```

This architecture ensures type safety, security, code reusability, and consistent data handling patterns throughout the application.